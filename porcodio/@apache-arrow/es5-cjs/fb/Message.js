"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Message = exports.DictionaryBatch = exports.RecordBatch = exports.BodyCompression = exports.FieldNode = exports.MessageHeader = exports.BodyCompressionMethod = exports.CompressionType = void 0;
var flatbuffers_1 = require("flatbuffers");
var NS13596923344997147894 = require("./Schema");
/**
 * @enum {number}
 */
var CompressionType;
(function (CompressionType) {
    CompressionType[CompressionType["LZ4_FRAME"] = 0] = "LZ4_FRAME";
    CompressionType[CompressionType["ZSTD"] = 1] = "ZSTD";
})(CompressionType = exports.CompressionType || (exports.CompressionType = {}));
/**
 * Provided for forward compatibility in case we need to support different
 * strategies for compressing the IPC message body (like whole-body
 * compression rather than buffer-level) in the future
 *
 * @enum {number}
 */
var BodyCompressionMethod;
(function (BodyCompressionMethod) {
    /**
     * Each constituent buffer is first compressed with the indicated
     * compressor, and then written with the uncompressed length in the first 8
     * bytes as a 64-bit little-endian signed integer followed by the compressed
     * buffer bytes (and then padding as required by the protocol). The
     * uncompressed length may be set to -1 to indicate that the data that
     * follows is not compressed, which can be useful for cases where
     * compression does not yield appreciable savings.
     */
    BodyCompressionMethod[BodyCompressionMethod["BUFFER"] = 0] = "BUFFER";
})(BodyCompressionMethod = exports.BodyCompressionMethod || (exports.BodyCompressionMethod = {}));
/**
 * ----------------------------------------------------------------------
 * The root Message type
 * This union enables us to easily send different message types without
 * redundant storage, and in the future we can easily add new message types.
 *
 * Arrow implementations do not need to implement all of the message types,
 * which may include experimental metadata types. For maximum compatibility,
 * it is best to send data using RecordBatch
 *
 * @enum {number}
 */
var MessageHeader;
(function (MessageHeader) {
    MessageHeader[MessageHeader["NONE"] = 0] = "NONE";
    MessageHeader[MessageHeader["Schema"] = 1] = "Schema";
    MessageHeader[MessageHeader["DictionaryBatch"] = 2] = "DictionaryBatch";
    MessageHeader[MessageHeader["RecordBatch"] = 3] = "RecordBatch";
    MessageHeader[MessageHeader["Tensor"] = 4] = "Tensor";
    MessageHeader[MessageHeader["SparseTensor"] = 5] = "SparseTensor";
})(MessageHeader = exports.MessageHeader || (exports.MessageHeader = {}));
/**
 * ----------------------------------------------------------------------
 * Data structures for describing a table row batch (a collection of
 * equal-length Arrow arrays)
 * Metadata about a field at some level of a nested type tree (but not
 * its children).
 *
 * For example, a List<Int16> with values [[1, 2, 3], null, [4], [5, 6], null]
 * would have {length: 5, null_count: 2} for its List node, and {length: 6,
 * null_count: 0} for its Int16 node, as separate FieldNode structs
 *
 * @constructor
 */
var FieldNode = /** @class */ (function () {
    function FieldNode() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns FieldNode
     */
    FieldNode.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * The number of value slots in the Arrow array at this level of a nested
     * tree
     *
     * @returns flatbuffers.Long
     */
    FieldNode.prototype.length = function () {
        return this.bb.readInt64(this.bb_pos);
    };
    /**
     * The number of observed nulls. Fields with null_count == 0 may choose not
     * to write their physical validity bitmap out as a materialized buffer,
     * instead setting the length of the bitmap buffer to 0.
     *
     * @returns flatbuffers.Long
     */
    FieldNode.prototype.nullCount = function () {
        return this.bb.readInt64(this.bb_pos + 8);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long length
     * @param flatbuffers.Long null_count
     * @returns flatbuffers.Offset
     */
    FieldNode.createFieldNode = function (builder, length, null_count) {
        builder.prep(8, 16);
        builder.writeInt64(null_count);
        builder.writeInt64(length);
        return builder.offset();
    };
    return FieldNode;
}());
exports.FieldNode = FieldNode;
/**
 * Optional compression for the memory buffers constituting IPC message
 * bodies. Intended for use with RecordBatch but could be used for other
 * message types
 *
 * @constructor
 */
var BodyCompression = /** @class */ (function () {
    function BodyCompression() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns BodyCompression
     */
    BodyCompression.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param BodyCompression= obj
     * @returns BodyCompression
     */
    BodyCompression.getRootAsBodyCompression = function (bb, obj) {
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param BodyCompression= obj
     * @returns BodyCompression
     */
    BodyCompression.getSizePrefixedRootAsBodyCompression = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new BodyCompression()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * Compressor library
     *
     * @returns CompressionType
     */
    BodyCompression.prototype.codec = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt8(this.bb_pos + offset)) : CompressionType.LZ4_FRAME;
    };
    /**
     * Indicates the way the record batch body was compressed
     *
     * @returns BodyCompressionMethod
     */
    BodyCompression.prototype.method = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? /**  */ (this.bb.readInt8(this.bb_pos + offset)) : BodyCompressionMethod.BUFFER;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    BodyCompression.startBodyCompression = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param CompressionType codec
     */
    BodyCompression.addCodec = function (builder, codec) {
        builder.addFieldInt8(0, codec, CompressionType.LZ4_FRAME);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param BodyCompressionMethod method
     */
    BodyCompression.addMethod = function (builder, method) {
        builder.addFieldInt8(1, method, BodyCompressionMethod.BUFFER);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    BodyCompression.endBodyCompression = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    BodyCompression.createBodyCompression = function (builder, codec, method) {
        BodyCompression.startBodyCompression(builder);
        BodyCompression.addCodec(builder, codec);
        BodyCompression.addMethod(builder, method);
        return BodyCompression.endBodyCompression(builder);
    };
    return BodyCompression;
}());
exports.BodyCompression = BodyCompression;
/**
 * A data header describing the shared memory layout of a "record" or "row"
 * batch. Some systems call this a "row batch" internally and others a "record
 * batch".
 *
 * @constructor
 */
var RecordBatch = /** @class */ (function () {
    function RecordBatch() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns RecordBatch
     */
    RecordBatch.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param RecordBatch= obj
     * @returns RecordBatch
     */
    RecordBatch.getRootAsRecordBatch = function (bb, obj) {
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param RecordBatch= obj
     * @returns RecordBatch
     */
    RecordBatch.getSizePrefixedRootAsRecordBatch = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new RecordBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * number of records / rows. The arrays in the batch should all have this
     * length
     *
     * @returns flatbuffers.Long
     */
    RecordBatch.prototype.length = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    };
    /**
     * Nodes correspond to the pre-ordered flattened logical schema
     *
     * @param number index
     * @param FieldNode= obj
     * @returns FieldNode
     */
    RecordBatch.prototype.nodes = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new FieldNode()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    };
    /**
     * @returns number
     */
    RecordBatch.prototype.nodesLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * Buffers correspond to the pre-ordered flattened buffer tree
     *
     * The number of buffers appended to this list depends on the schema. For
     * example, most primitive arrays will have 2 buffers, 1 for the validity
     * bitmap and 1 for the values. For struct arrays, there will only be a
     * single buffer for the validity (nulls) bitmap
     *
     * @param number index
     * @param Buffer= obj
     * @returns Buffer
     */
    RecordBatch.prototype.buffers = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new NS13596923344997147894.Buffer()).__init(this.bb.__vector(this.bb_pos + offset) + index * 16, this.bb) : null;
    };
    /**
     * @returns number
     */
    RecordBatch.prototype.buffersLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * Optional compression of the message body
     *
     * @param BodyCompression= obj
     * @returns BodyCompression|null
     */
    RecordBatch.prototype.compression = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? (obj || new BodyCompression()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    RecordBatch.startRecordBatch = function (builder) {
        builder.startObject(4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long length
     */
    RecordBatch.addLength = function (builder, length) {
        builder.addFieldInt64(0, length, builder.createLong(0, 0));
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset nodesOffset
     */
    RecordBatch.addNodes = function (builder, nodesOffset) {
        builder.addFieldOffset(1, nodesOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    RecordBatch.startNodesVector = function (builder, numElems) {
        builder.startVector(16, numElems, 8);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset buffersOffset
     */
    RecordBatch.addBuffers = function (builder, buffersOffset) {
        builder.addFieldOffset(2, buffersOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    RecordBatch.startBuffersVector = function (builder, numElems) {
        builder.startVector(16, numElems, 8);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset compressionOffset
     */
    RecordBatch.addCompression = function (builder, compressionOffset) {
        builder.addFieldOffset(3, compressionOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    RecordBatch.endRecordBatch = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    RecordBatch.createRecordBatch = function (builder, length, nodesOffset, buffersOffset, compressionOffset) {
        RecordBatch.startRecordBatch(builder);
        RecordBatch.addLength(builder, length);
        RecordBatch.addNodes(builder, nodesOffset);
        RecordBatch.addBuffers(builder, buffersOffset);
        RecordBatch.addCompression(builder, compressionOffset);
        return RecordBatch.endRecordBatch(builder);
    };
    return RecordBatch;
}());
exports.RecordBatch = RecordBatch;
/**
 * For sending dictionary encoding information. Any Field can be
 * dictionary-encoded, but in this case none of its children may be
 * dictionary-encoded.
 * There is one vector / column per dictionary, but that vector / column
 * may be spread across multiple dictionary batches by using the isDelta
 * flag
 *
 * @constructor
 */
var DictionaryBatch = /** @class */ (function () {
    function DictionaryBatch() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns DictionaryBatch
     */
    DictionaryBatch.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param DictionaryBatch= obj
     * @returns DictionaryBatch
     */
    DictionaryBatch.getRootAsDictionaryBatch = function (bb, obj) {
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param DictionaryBatch= obj
     * @returns DictionaryBatch
     */
    DictionaryBatch.getSizePrefixedRootAsDictionaryBatch = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryBatch()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns flatbuffers.Long
     */
    DictionaryBatch.prototype.id = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    };
    /**
     * @param RecordBatch= obj
     * @returns RecordBatch|null
     */
    DictionaryBatch.prototype.data = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new RecordBatch()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * If isDelta is true the values in the dictionary are to be appended to a
     * dictionary with the indicated id. If isDelta is false this dictionary
     * should replace the existing dictionary.
     *
     * @returns boolean
     */
    DictionaryBatch.prototype.isDelta = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    DictionaryBatch.startDictionaryBatch = function (builder) {
        builder.startObject(3);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long id
     */
    DictionaryBatch.addId = function (builder, id) {
        builder.addFieldInt64(0, id, builder.createLong(0, 0));
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset dataOffset
     */
    DictionaryBatch.addData = function (builder, dataOffset) {
        builder.addFieldOffset(1, dataOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param boolean isDelta
     */
    DictionaryBatch.addIsDelta = function (builder, isDelta) {
        builder.addFieldInt8(2, +isDelta, +false);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    DictionaryBatch.endDictionaryBatch = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    DictionaryBatch.createDictionaryBatch = function (builder, id, dataOffset, isDelta) {
        DictionaryBatch.startDictionaryBatch(builder);
        DictionaryBatch.addId(builder, id);
        DictionaryBatch.addData(builder, dataOffset);
        DictionaryBatch.addIsDelta(builder, isDelta);
        return DictionaryBatch.endDictionaryBatch(builder);
    };
    return DictionaryBatch;
}());
exports.DictionaryBatch = DictionaryBatch;
/**
 * @constructor
 */
var Message = /** @class */ (function () {
    function Message() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Message
     */
    Message.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Message= obj
     * @returns Message
     */
    Message.getRootAsMessage = function (bb, obj) {
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Message= obj
     * @returns Message
     */
    Message.getSizePrefixedRootAsMessage = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Message()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns MetadataVersion
     */
    Message.prototype.version = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : NS13596923344997147894.MetadataVersion.V1;
    };
    /**
     * @returns MessageHeader
     */
    Message.prototype.headerType = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? /**  */ (this.bb.readUint8(this.bb_pos + offset)) : MessageHeader.NONE;
    };
    /**
     * @param flatbuffers.Table obj
     * @returns ?flatbuffers.Table
     */
    Message.prototype.header = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    };
    /**
     * @returns flatbuffers.Long
     */
    Message.prototype.bodyLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    };
    /**
     * @param number index
     * @param KeyValue= obj
     * @returns KeyValue
     */
    Message.prototype.customMetadata = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new NS13596923344997147894.KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    /**
     * @returns number
     */
    Message.prototype.customMetadataLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Message.startMessage = function (builder) {
        builder.startObject(5);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param MetadataVersion version
     */
    Message.addVersion = function (builder, version) {
        builder.addFieldInt16(0, version, NS13596923344997147894.MetadataVersion.V1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param MessageHeader headerType
     */
    Message.addHeaderType = function (builder, headerType) {
        builder.addFieldInt8(1, headerType, MessageHeader.NONE);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset headerOffset
     */
    Message.addHeader = function (builder, headerOffset) {
        builder.addFieldOffset(2, headerOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long bodyLength
     */
    Message.addBodyLength = function (builder, bodyLength) {
        builder.addFieldInt64(3, bodyLength, builder.createLong(0, 0));
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset customMetadataOffset
     */
    Message.addCustomMetadata = function (builder, customMetadataOffset) {
        builder.addFieldOffset(4, customMetadataOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Offset> data
     * @returns flatbuffers.Offset
     */
    Message.createCustomMetadataVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Message.startCustomMetadataVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Message.endMessage = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset offset
     */
    Message.finishMessageBuffer = function (builder, offset) {
        builder.finish(offset);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset offset
     */
    Message.finishSizePrefixedMessageBuffer = function (builder, offset) {
        builder.finish(offset, undefined, true);
    };
    Message.createMessage = function (builder, version, headerType, headerOffset, bodyLength, customMetadataOffset) {
        Message.startMessage(builder);
        Message.addVersion(builder, version);
        Message.addHeaderType(builder, headerType);
        Message.addHeader(builder, headerOffset);
        Message.addBodyLength(builder, bodyLength);
        Message.addCustomMetadata(builder, customMetadataOffset);
        return Message.endMessage(builder);
    };
    return Message;
}());
exports.Message = Message;

//# sourceMappingURL=Message.js.map
