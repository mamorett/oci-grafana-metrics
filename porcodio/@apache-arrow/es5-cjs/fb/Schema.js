"use strict";
// automatically generated by the FlatBuffers compiler, do not modify
Object.defineProperty(exports, "__esModule", { value: true });
exports.Schema = exports.Buffer = exports.Field = exports.DictionaryEncoding = exports.KeyValue = exports.Duration = exports.Interval = exports.Timestamp = exports.Time = exports.Date = exports.Decimal = exports.Bool = exports.FixedSizeBinary = exports.LargeBinary = exports.LargeUtf8 = exports.Binary = exports.Utf8 = exports.FloatingPoint = exports.Int = exports.Union = exports.Map = exports.FixedSizeList = exports.LargeList = exports.List = exports.Struct_ = exports.Null = exports.Endianness = exports.DictionaryKind = exports.Type = exports.IntervalUnit = exports.TimeUnit = exports.DateUnit = exports.Precision = exports.UnionMode = exports.Feature = exports.MetadataVersion = void 0;
var flatbuffers_1 = require("flatbuffers");
/**
 * Logical types, vector layouts, and schemas
 *
 * @enum {number}
 */
var MetadataVersion;
(function (MetadataVersion) {
    /**
     * 0.1.0 (October 2016).
     */
    MetadataVersion[MetadataVersion["V1"] = 0] = "V1";
    /**
     * 0.2.0 (February 2017). Non-backwards compatible with V1.
     */
    MetadataVersion[MetadataVersion["V2"] = 1] = "V2";
    /**
     * 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
     */
    MetadataVersion[MetadataVersion["V3"] = 2] = "V3";
    /**
     * >= 0.8.0 (December 2017). Non-backwards compatible with V3.
     */
    MetadataVersion[MetadataVersion["V4"] = 3] = "V4";
    /**
     * >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
     * metadata and IPC messages). Implementations are recommended to provide a
     * V4 compatibility mode with V5 format changes disabled.
     *
     * Incompatible changes between V4 and V5:
     * - Union buffer layout has changed. In V5, Unions don't have a validity
     *   bitmap buffer.
     */
    MetadataVersion[MetadataVersion["V5"] = 4] = "V5";
})(MetadataVersion = exports.MetadataVersion || (exports.MetadataVersion = {}));
/**
 * Represents Arrow Features that might not have full support
 * within implementations. This is intended to be used in
 * two scenarios:
 *  1.  A mechanism for readers of Arrow Streams
 *      and files to understand that the stream or file makes
 *      use of a feature that isn't supported or unknown to
 *      the implementation (and therefore can meet the Arrow
 *      forward compatibility guarantees).
 *  2.  A means of negotiating between a client and server
 *      what features a stream is allowed to use. The enums
 *      values here are intented to represent higher level
 *      features, additional details maybe negotiated
 *      with key-value pairs specific to the protocol.
 *
 * Enums added to this list should be assigned power-of-two values
 * to facilitate exchanging and comparing bitmaps for supported
 * features.
 *
 * @enum {number}
 */
var Feature;
(function (Feature) {
    /**
     * Needed to make flatbuffers happy.
     */
    Feature[Feature["UNUSED"] = 0] = "UNUSED";
    /**
     * The stream makes use of multiple full dictionaries with the
     * same ID and assumes clients implement dictionary replacement
     * correctly.
     */
    Feature[Feature["DICTIONARY_REPLACEMENT"] = 1] = "DICTIONARY_REPLACEMENT";
    /**
     * The stream makes use of compressed bodies as described
     * in Message.fbs.
     */
    Feature[Feature["COMPRESSED_BODY"] = 2] = "COMPRESSED_BODY";
})(Feature = exports.Feature || (exports.Feature = {}));
/**
 * @enum {number}
 */
var UnionMode;
(function (UnionMode) {
    UnionMode[UnionMode["Sparse"] = 0] = "Sparse";
    UnionMode[UnionMode["Dense"] = 1] = "Dense";
})(UnionMode = exports.UnionMode || (exports.UnionMode = {}));
/**
 * @enum {number}
 */
var Precision;
(function (Precision) {
    Precision[Precision["HALF"] = 0] = "HALF";
    Precision[Precision["SINGLE"] = 1] = "SINGLE";
    Precision[Precision["DOUBLE"] = 2] = "DOUBLE";
})(Precision = exports.Precision || (exports.Precision = {}));
/**
 * @enum {number}
 */
var DateUnit;
(function (DateUnit) {
    DateUnit[DateUnit["DAY"] = 0] = "DAY";
    DateUnit[DateUnit["MILLISECOND"] = 1] = "MILLISECOND";
})(DateUnit = exports.DateUnit || (exports.DateUnit = {}));
/**
 * @enum {number}
 */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit[TimeUnit["SECOND"] = 0] = "SECOND";
    TimeUnit[TimeUnit["MILLISECOND"] = 1] = "MILLISECOND";
    TimeUnit[TimeUnit["MICROSECOND"] = 2] = "MICROSECOND";
    TimeUnit[TimeUnit["NANOSECOND"] = 3] = "NANOSECOND";
})(TimeUnit = exports.TimeUnit || (exports.TimeUnit = {}));
/**
 * @enum {number}
 */
var IntervalUnit;
(function (IntervalUnit) {
    IntervalUnit[IntervalUnit["YEAR_MONTH"] = 0] = "YEAR_MONTH";
    IntervalUnit[IntervalUnit["DAY_TIME"] = 1] = "DAY_TIME";
})(IntervalUnit = exports.IntervalUnit || (exports.IntervalUnit = {}));
/**
 * ----------------------------------------------------------------------
 * Top-level Type value, enabling extensible type-specific metadata. We can
 * add new logical types to Type without breaking backwards compatibility
 *
 * @enum {number}
 */
var Type;
(function (Type) {
    Type[Type["NONE"] = 0] = "NONE";
    Type[Type["Null"] = 1] = "Null";
    Type[Type["Int"] = 2] = "Int";
    Type[Type["FloatingPoint"] = 3] = "FloatingPoint";
    Type[Type["Binary"] = 4] = "Binary";
    Type[Type["Utf8"] = 5] = "Utf8";
    Type[Type["Bool"] = 6] = "Bool";
    Type[Type["Decimal"] = 7] = "Decimal";
    Type[Type["Date"] = 8] = "Date";
    Type[Type["Time"] = 9] = "Time";
    Type[Type["Timestamp"] = 10] = "Timestamp";
    Type[Type["Interval"] = 11] = "Interval";
    Type[Type["List"] = 12] = "List";
    Type[Type["Struct_"] = 13] = "Struct_";
    Type[Type["Union"] = 14] = "Union";
    Type[Type["FixedSizeBinary"] = 15] = "FixedSizeBinary";
    Type[Type["FixedSizeList"] = 16] = "FixedSizeList";
    Type[Type["Map"] = 17] = "Map";
    Type[Type["Duration"] = 18] = "Duration";
    Type[Type["LargeBinary"] = 19] = "LargeBinary";
    Type[Type["LargeUtf8"] = 20] = "LargeUtf8";
    Type[Type["LargeList"] = 21] = "LargeList";
})(Type = exports.Type || (exports.Type = {}));
/**
 * ----------------------------------------------------------------------
 * Dictionary encoding metadata
 * Maintained for forwards compatibility, in the future
 * Dictionaries might be explicit maps between integers and values
 * allowing for non-contiguous index values
 *
 * @enum {number}
 */
var DictionaryKind;
(function (DictionaryKind) {
    DictionaryKind[DictionaryKind["DenseArray"] = 0] = "DenseArray";
})(DictionaryKind = exports.DictionaryKind || (exports.DictionaryKind = {}));
/**
 * ----------------------------------------------------------------------
 * Endianness of the platform producing the data
 *
 * @enum {number}
 */
var Endianness;
(function (Endianness) {
    Endianness[Endianness["Little"] = 0] = "Little";
    Endianness[Endianness["Big"] = 1] = "Big";
})(Endianness = exports.Endianness || (exports.Endianness = {}));
/**
 * These are stored in the flatbuffer in the Type union below
 *
 * @constructor
 */
var Null = /** @class */ (function () {
    function Null() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Null
     */
    Null.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Null= obj
     * @returns Null
     */
    Null.getRootAsNull = function (bb, obj) {
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Null= obj
     * @returns Null
     */
    Null.getSizePrefixedRootAsNull = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Null()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Null.startNull = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Null.endNull = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Null.createNull = function (builder) {
        Null.startNull(builder);
        return Null.endNull(builder);
    };
    return Null;
}());
exports.Null = Null;
/**
 * A Struct_ in the flatbuffer metadata is the same as an Arrow Struct
 * (according to the physical memory layout). We used Struct_ here as
 * Struct is a reserved word in Flatbuffers
 *
 * @constructor
 */
var Struct_ = /** @class */ (function () {
    function Struct_() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Struct_
     */
    Struct_.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Struct_= obj
     * @returns Struct_
     */
    Struct_.getRootAsStruct_ = function (bb, obj) {
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Struct_= obj
     * @returns Struct_
     */
    Struct_.getSizePrefixedRootAsStruct_ = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Struct_()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Struct_.startStruct_ = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Struct_.endStruct_ = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Struct_.createStruct_ = function (builder) {
        Struct_.startStruct_(builder);
        return Struct_.endStruct_(builder);
    };
    return Struct_;
}());
exports.Struct_ = Struct_;
/**
 * @constructor
 */
var List = /** @class */ (function () {
    function List() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns List
     */
    List.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param List= obj
     * @returns List
     */
    List.getRootAsList = function (bb, obj) {
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param List= obj
     * @returns List
     */
    List.getSizePrefixedRootAsList = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new List()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    List.startList = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    List.endList = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    List.createList = function (builder) {
        List.startList(builder);
        return List.endList(builder);
    };
    return List;
}());
exports.List = List;
/**
 * Same as List, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
var LargeList = /** @class */ (function () {
    function LargeList() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns LargeList
     */
    LargeList.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeList= obj
     * @returns LargeList
     */
    LargeList.getRootAsLargeList = function (bb, obj) {
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeList= obj
     * @returns LargeList
     */
    LargeList.getSizePrefixedRootAsLargeList = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    LargeList.startLargeList = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    LargeList.endLargeList = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    LargeList.createLargeList = function (builder) {
        LargeList.startLargeList(builder);
        return LargeList.endLargeList(builder);
    };
    return LargeList;
}());
exports.LargeList = LargeList;
/**
 * @constructor
 */
var FixedSizeList = /** @class */ (function () {
    function FixedSizeList() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns FixedSizeList
     */
    FixedSizeList.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FixedSizeList= obj
     * @returns FixedSizeList
     */
    FixedSizeList.getRootAsFixedSizeList = function (bb, obj) {
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FixedSizeList= obj
     * @returns FixedSizeList
     */
    FixedSizeList.getSizePrefixedRootAsFixedSizeList = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeList()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * Number of list items per value
     *
     * @returns number
     */
    FixedSizeList.prototype.listSize = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    FixedSizeList.startFixedSizeList = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number listSize
     */
    FixedSizeList.addListSize = function (builder, listSize) {
        builder.addFieldInt32(0, listSize, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    FixedSizeList.endFixedSizeList = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    FixedSizeList.createFixedSizeList = function (builder, listSize) {
        FixedSizeList.startFixedSizeList(builder);
        FixedSizeList.addListSize(builder, listSize);
        return FixedSizeList.endFixedSizeList(builder);
    };
    return FixedSizeList;
}());
exports.FixedSizeList = FixedSizeList;
/**
 * A Map is a logical nested type that is represented as
 *
 * List<entries: Struct<key: K, value: V>>
 *
 * In this layout, the keys and values are each respectively contiguous. We do
 * not constrain the key and value types, so the application is responsible
 * for ensuring that the keys are hashable and unique. Whether the keys are sorted
 * may be set in the metadata for this field.
 *
 * In a field with Map type, the field has a child Struct field, which then
 * has two children: key type and the second the value type. The names of the
 * child fields may be respectively "entries", "key", and "value", but this is
 * not enforced.
 *
 * Map
 *   - child[0] entries: Struct
 *     - child[0] key: K
 *     - child[1] value: V
 *
 * Neither the "entries" field nor the "key" field may be nullable.
 *
 * The metadata is structured so that Arrow systems without special handling
 * for Map can make Map an alias for List. The "layout" attribute for the Map
 * field must have the same contents as a List.
 *
 * @constructor
 */
var Map = /** @class */ (function () {
    function Map() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Map
     */
    Map.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Map= obj
     * @returns Map
     */
    Map.getRootAsMap = function (bb, obj) {
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Map= obj
     * @returns Map
     */
    Map.getSizePrefixedRootAsMap = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Map()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * Set to true if the keys within each value are sorted
     *
     * @returns boolean
     */
    Map.prototype.keysSorted = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Map.startMap = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param boolean keysSorted
     */
    Map.addKeysSorted = function (builder, keysSorted) {
        builder.addFieldInt8(0, +keysSorted, +false);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Map.endMap = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Map.createMap = function (builder, keysSorted) {
        Map.startMap(builder);
        Map.addKeysSorted(builder, keysSorted);
        return Map.endMap(builder);
    };
    return Map;
}());
exports.Map = Map;
/**
 * A union is a complex type with children in Field
 * By default ids in the type vector refer to the offsets in the children
 * optionally typeIds provides an indirection between the child offset and the type id
 * for each child typeIds[offset] is the id used in the type vector
 *
 * @constructor
 */
var Union = /** @class */ (function () {
    function Union() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Union
     */
    Union.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Union= obj
     * @returns Union
     */
    Union.getRootAsUnion = function (bb, obj) {
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Union= obj
     * @returns Union
     */
    Union.getSizePrefixedRootAsUnion = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Union()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns UnionMode
     */
    Union.prototype.mode = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : UnionMode.Sparse;
    };
    /**
     * @param number index
     * @returns number
     */
    Union.prototype.typeIds = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
    };
    /**
     * @returns number
     */
    Union.prototype.typeIdsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * @returns Int32Array
     */
    Union.prototype.typeIdsArray = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Union.startUnion = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param UnionMode mode
     */
    Union.addMode = function (builder, mode) {
        builder.addFieldInt16(0, mode, UnionMode.Sparse);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset typeIdsOffset
     */
    Union.addTypeIds = function (builder, typeIdsOffset) {
        builder.addFieldOffset(1, typeIdsOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<number> data
     * @returns flatbuffers.Offset
     */
    Union.createTypeIdsVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt32(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Union.startTypeIdsVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Union.endUnion = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Union.createUnion = function (builder, mode, typeIdsOffset) {
        Union.startUnion(builder);
        Union.addMode(builder, mode);
        Union.addTypeIds(builder, typeIdsOffset);
        return Union.endUnion(builder);
    };
    return Union;
}());
exports.Union = Union;
/**
 * @constructor
 */
var Int = /** @class */ (function () {
    function Int() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Int
     */
    Int.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Int= obj
     * @returns Int
     */
    Int.getRootAsInt = function (bb, obj) {
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Int= obj
     * @returns Int
     */
    Int.getSizePrefixedRootAsInt = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Int()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns number
     */
    Int.prototype.bitWidth = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    /**
     * @returns boolean
     */
    Int.prototype.isSigned = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Int.startInt = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number bitWidth
     */
    Int.addBitWidth = function (builder, bitWidth) {
        builder.addFieldInt32(0, bitWidth, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param boolean isSigned
     */
    Int.addIsSigned = function (builder, isSigned) {
        builder.addFieldInt8(1, +isSigned, +false);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Int.endInt = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Int.createInt = function (builder, bitWidth, isSigned) {
        Int.startInt(builder);
        Int.addBitWidth(builder, bitWidth);
        Int.addIsSigned(builder, isSigned);
        return Int.endInt(builder);
    };
    return Int;
}());
exports.Int = Int;
/**
 * @constructor
 */
var FloatingPoint = /** @class */ (function () {
    function FloatingPoint() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns FloatingPoint
     */
    FloatingPoint.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FloatingPoint= obj
     * @returns FloatingPoint
     */
    FloatingPoint.getRootAsFloatingPoint = function (bb, obj) {
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FloatingPoint= obj
     * @returns FloatingPoint
     */
    FloatingPoint.getSizePrefixedRootAsFloatingPoint = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FloatingPoint()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns Precision
     */
    FloatingPoint.prototype.precision = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : Precision.HALF;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    FloatingPoint.startFloatingPoint = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Precision precision
     */
    FloatingPoint.addPrecision = function (builder, precision) {
        builder.addFieldInt16(0, precision, Precision.HALF);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    FloatingPoint.endFloatingPoint = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    FloatingPoint.createFloatingPoint = function (builder, precision) {
        FloatingPoint.startFloatingPoint(builder);
        FloatingPoint.addPrecision(builder, precision);
        return FloatingPoint.endFloatingPoint(builder);
    };
    return FloatingPoint;
}());
exports.FloatingPoint = FloatingPoint;
/**
 * Unicode with UTF-8 encoding
 *
 * @constructor
 */
var Utf8 = /** @class */ (function () {
    function Utf8() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Utf8
     */
    Utf8.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Utf8= obj
     * @returns Utf8
     */
    Utf8.getRootAsUtf8 = function (bb, obj) {
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Utf8= obj
     * @returns Utf8
     */
    Utf8.getSizePrefixedRootAsUtf8 = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Utf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Utf8.startUtf8 = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Utf8.endUtf8 = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Utf8.createUtf8 = function (builder) {
        Utf8.startUtf8(builder);
        return Utf8.endUtf8(builder);
    };
    return Utf8;
}());
exports.Utf8 = Utf8;
/**
 * Opaque binary data
 *
 * @constructor
 */
var Binary = /** @class */ (function () {
    function Binary() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Binary
     */
    Binary.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Binary= obj
     * @returns Binary
     */
    Binary.getRootAsBinary = function (bb, obj) {
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Binary= obj
     * @returns Binary
     */
    Binary.getSizePrefixedRootAsBinary = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Binary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Binary.startBinary = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Binary.endBinary = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Binary.createBinary = function (builder) {
        Binary.startBinary(builder);
        return Binary.endBinary(builder);
    };
    return Binary;
}());
exports.Binary = Binary;
/**
 * Same as Utf8, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
var LargeUtf8 = /** @class */ (function () {
    function LargeUtf8() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns LargeUtf8
     */
    LargeUtf8.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeUtf8= obj
     * @returns LargeUtf8
     */
    LargeUtf8.getRootAsLargeUtf8 = function (bb, obj) {
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeUtf8= obj
     * @returns LargeUtf8
     */
    LargeUtf8.getSizePrefixedRootAsLargeUtf8 = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeUtf8()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    LargeUtf8.startLargeUtf8 = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    LargeUtf8.endLargeUtf8 = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    LargeUtf8.createLargeUtf8 = function (builder) {
        LargeUtf8.startLargeUtf8(builder);
        return LargeUtf8.endLargeUtf8(builder);
    };
    return LargeUtf8;
}());
exports.LargeUtf8 = LargeUtf8;
/**
 * Same as Binary, but with 64-bit offsets, allowing to represent
 * extremely large data values.
 *
 * @constructor
 */
var LargeBinary = /** @class */ (function () {
    function LargeBinary() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns LargeBinary
     */
    LargeBinary.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeBinary= obj
     * @returns LargeBinary
     */
    LargeBinary.getRootAsLargeBinary = function (bb, obj) {
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param LargeBinary= obj
     * @returns LargeBinary
     */
    LargeBinary.getSizePrefixedRootAsLargeBinary = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new LargeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    LargeBinary.startLargeBinary = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    LargeBinary.endLargeBinary = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    LargeBinary.createLargeBinary = function (builder) {
        LargeBinary.startLargeBinary(builder);
        return LargeBinary.endLargeBinary(builder);
    };
    return LargeBinary;
}());
exports.LargeBinary = LargeBinary;
/**
 * @constructor
 */
var FixedSizeBinary = /** @class */ (function () {
    function FixedSizeBinary() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns FixedSizeBinary
     */
    FixedSizeBinary.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FixedSizeBinary= obj
     * @returns FixedSizeBinary
     */
    FixedSizeBinary.getRootAsFixedSizeBinary = function (bb, obj) {
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param FixedSizeBinary= obj
     * @returns FixedSizeBinary
     */
    FixedSizeBinary.getSizePrefixedRootAsFixedSizeBinary = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new FixedSizeBinary()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * Number of bytes per value
     *
     * @returns number
     */
    FixedSizeBinary.prototype.byteWidth = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    FixedSizeBinary.startFixedSizeBinary = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number byteWidth
     */
    FixedSizeBinary.addByteWidth = function (builder, byteWidth) {
        builder.addFieldInt32(0, byteWidth, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    FixedSizeBinary.endFixedSizeBinary = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    FixedSizeBinary.createFixedSizeBinary = function (builder, byteWidth) {
        FixedSizeBinary.startFixedSizeBinary(builder);
        FixedSizeBinary.addByteWidth(builder, byteWidth);
        return FixedSizeBinary.endFixedSizeBinary(builder);
    };
    return FixedSizeBinary;
}());
exports.FixedSizeBinary = FixedSizeBinary;
/**
 * @constructor
 */
var Bool = /** @class */ (function () {
    function Bool() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Bool
     */
    Bool.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Bool= obj
     * @returns Bool
     */
    Bool.getRootAsBool = function (bb, obj) {
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Bool= obj
     * @returns Bool
     */
    Bool.getSizePrefixedRootAsBool = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Bool()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Bool.startBool = function (builder) {
        builder.startObject(0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Bool.endBool = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Bool.createBool = function (builder) {
        Bool.startBool(builder);
        return Bool.endBool(builder);
    };
    return Bool;
}());
exports.Bool = Bool;
/**
 * Exact decimal value represented as an integer value in two's
 * complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
 * are used. The representation uses the endianness indicated
 * in the Schema.
 *
 * @constructor
 */
var Decimal = /** @class */ (function () {
    function Decimal() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Decimal
     */
    Decimal.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Decimal= obj
     * @returns Decimal
     */
    Decimal.getRootAsDecimal = function (bb, obj) {
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Decimal= obj
     * @returns Decimal
     */
    Decimal.getSizePrefixedRootAsDecimal = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Decimal()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * Total number of decimal digits
     *
     * @returns number
     */
    Decimal.prototype.precision = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    /**
     * Number of digits after the decimal point "."
     *
     * @returns number
     */
    Decimal.prototype.scale = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 0;
    };
    /**
     * Number of bits per value. The only accepted widths are 128 and 256.
     * We use bitWidth for consistency with Int::bitWidth.
     *
     * @returns number
     */
    Decimal.prototype.bitWidth = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 128;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Decimal.startDecimal = function (builder) {
        builder.startObject(3);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number precision
     */
    Decimal.addPrecision = function (builder, precision) {
        builder.addFieldInt32(0, precision, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number scale
     */
    Decimal.addScale = function (builder, scale) {
        builder.addFieldInt32(1, scale, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number bitWidth
     */
    Decimal.addBitWidth = function (builder, bitWidth) {
        builder.addFieldInt32(2, bitWidth, 128);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Decimal.endDecimal = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Decimal.createDecimal = function (builder, precision, scale, bitWidth) {
        Decimal.startDecimal(builder);
        Decimal.addPrecision(builder, precision);
        Decimal.addScale(builder, scale);
        Decimal.addBitWidth(builder, bitWidth);
        return Decimal.endDecimal(builder);
    };
    return Decimal;
}());
exports.Decimal = Decimal;
/**
 * Date is either a 32-bit or 64-bit type representing elapsed time since UNIX
 * epoch (1970-01-01), stored in either of two units:
 *
 * * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no
 *   leap seconds), where the values are evenly divisible by 86400000
 * * Days (32 bits) since the UNIX epoch
 *
 * @constructor
 */
var Date = /** @class */ (function () {
    function Date() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Date
     */
    Date.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Date= obj
     * @returns Date
     */
    Date.getRootAsDate = function (bb, obj) {
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Date= obj
     * @returns Date
     */
    Date.getSizePrefixedRootAsDate = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Date()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns DateUnit
     */
    Date.prototype.unit = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : DateUnit.MILLISECOND;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Date.startDate = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param DateUnit unit
     */
    Date.addUnit = function (builder, unit) {
        builder.addFieldInt16(0, unit, DateUnit.MILLISECOND);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Date.endDate = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Date.createDate = function (builder, unit) {
        Date.startDate(builder);
        Date.addUnit(builder, unit);
        return Date.endDate(builder);
    };
    return Date;
}());
exports.Date = Date;
/**
 * Time type. The physical storage type depends on the unit
 * - SECOND and MILLISECOND: 32 bits
 * - MICROSECOND and NANOSECOND: 64 bits
 *
 * @constructor
 */
var Time = /** @class */ (function () {
    function Time() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Time
     */
    Time.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Time= obj
     * @returns Time
     */
    Time.getRootAsTime = function (bb, obj) {
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Time= obj
     * @returns Time
     */
    Time.getSizePrefixedRootAsTime = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Time()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns TimeUnit
     */
    Time.prototype.unit = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : TimeUnit.MILLISECOND;
    };
    /**
     * @returns number
     */
    Time.prototype.bitWidth = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.readInt32(this.bb_pos + offset) : 32;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Time.startTime = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param TimeUnit unit
     */
    Time.addUnit = function (builder, unit) {
        builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number bitWidth
     */
    Time.addBitWidth = function (builder, bitWidth) {
        builder.addFieldInt32(1, bitWidth, 32);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Time.endTime = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Time.createTime = function (builder, unit, bitWidth) {
        Time.startTime(builder);
        Time.addUnit(builder, unit);
        Time.addBitWidth(builder, bitWidth);
        return Time.endTime(builder);
    };
    return Time;
}());
exports.Time = Time;
/**
 * Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding
 * leap seconds, as a 64-bit integer. Note that UNIX time does not include
 * leap seconds.
 *
 * The Timestamp metadata supports both "time zone naive" and "time zone
 * aware" timestamps. Read about the timezone attribute for more detail
 *
 * @constructor
 */
var Timestamp = /** @class */ (function () {
    function Timestamp() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Timestamp
     */
    Timestamp.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Timestamp= obj
     * @returns Timestamp
     */
    Timestamp.getRootAsTimestamp = function (bb, obj) {
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Timestamp= obj
     * @returns Timestamp
     */
    Timestamp.getSizePrefixedRootAsTimestamp = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Timestamp()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns TimeUnit
     */
    Timestamp.prototype.unit = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : TimeUnit.SECOND;
    };
    Timestamp.prototype.timezone = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Timestamp.startTimestamp = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param TimeUnit unit
     */
    Timestamp.addUnit = function (builder, unit) {
        builder.addFieldInt16(0, unit, TimeUnit.SECOND);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset timezoneOffset
     */
    Timestamp.addTimezone = function (builder, timezoneOffset) {
        builder.addFieldOffset(1, timezoneOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Timestamp.endTimestamp = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Timestamp.createTimestamp = function (builder, unit, timezoneOffset) {
        Timestamp.startTimestamp(builder);
        Timestamp.addUnit(builder, unit);
        Timestamp.addTimezone(builder, timezoneOffset);
        return Timestamp.endTimestamp(builder);
    };
    return Timestamp;
}());
exports.Timestamp = Timestamp;
/**
 * @constructor
 */
var Interval = /** @class */ (function () {
    function Interval() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Interval
     */
    Interval.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Interval= obj
     * @returns Interval
     */
    Interval.getRootAsInterval = function (bb, obj) {
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Interval= obj
     * @returns Interval
     */
    Interval.getSizePrefixedRootAsInterval = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Interval()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns IntervalUnit
     */
    Interval.prototype.unit = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : IntervalUnit.YEAR_MONTH;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Interval.startInterval = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param IntervalUnit unit
     */
    Interval.addUnit = function (builder, unit) {
        builder.addFieldInt16(0, unit, IntervalUnit.YEAR_MONTH);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Interval.endInterval = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Interval.createInterval = function (builder, unit) {
        Interval.startInterval(builder);
        Interval.addUnit(builder, unit);
        return Interval.endInterval(builder);
    };
    return Interval;
}());
exports.Interval = Interval;
/**
 * @constructor
 */
var Duration = /** @class */ (function () {
    function Duration() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Duration
     */
    Duration.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Duration= obj
     * @returns Duration
     */
    Duration.getRootAsDuration = function (bb, obj) {
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Duration= obj
     * @returns Duration
     */
    Duration.getSizePrefixedRootAsDuration = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Duration()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @returns TimeUnit
     */
    Duration.prototype.unit = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : TimeUnit.MILLISECOND;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Duration.startDuration = function (builder) {
        builder.startObject(1);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param TimeUnit unit
     */
    Duration.addUnit = function (builder, unit) {
        builder.addFieldInt16(0, unit, TimeUnit.MILLISECOND);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Duration.endDuration = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Duration.createDuration = function (builder, unit) {
        Duration.startDuration(builder);
        Duration.addUnit(builder, unit);
        return Duration.endDuration(builder);
    };
    return Duration;
}());
exports.Duration = Duration;
/**
 * ----------------------------------------------------------------------
 * user defined key value pairs to add custom metadata to arrow
 * key namespacing is the responsibility of the user
 *
 * @constructor
 */
var KeyValue = /** @class */ (function () {
    function KeyValue() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns KeyValue
     */
    KeyValue.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param KeyValue= obj
     * @returns KeyValue
     */
    KeyValue.getRootAsKeyValue = function (bb, obj) {
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param KeyValue= obj
     * @returns KeyValue
     */
    KeyValue.getSizePrefixedRootAsKeyValue = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new KeyValue()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    KeyValue.prototype.key = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    KeyValue.prototype.value = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    KeyValue.startKeyValue = function (builder) {
        builder.startObject(2);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset keyOffset
     */
    KeyValue.addKey = function (builder, keyOffset) {
        builder.addFieldOffset(0, keyOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset valueOffset
     */
    KeyValue.addValue = function (builder, valueOffset) {
        builder.addFieldOffset(1, valueOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    KeyValue.endKeyValue = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    KeyValue.createKeyValue = function (builder, keyOffset, valueOffset) {
        KeyValue.startKeyValue(builder);
        KeyValue.addKey(builder, keyOffset);
        KeyValue.addValue(builder, valueOffset);
        return KeyValue.endKeyValue(builder);
    };
    return KeyValue;
}());
exports.KeyValue = KeyValue;
/**
 * @constructor
 */
var DictionaryEncoding = /** @class */ (function () {
    function DictionaryEncoding() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns DictionaryEncoding
     */
    DictionaryEncoding.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param DictionaryEncoding= obj
     * @returns DictionaryEncoding
     */
    DictionaryEncoding.getRootAsDictionaryEncoding = function (bb, obj) {
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param DictionaryEncoding= obj
     * @returns DictionaryEncoding
     */
    DictionaryEncoding.getSizePrefixedRootAsDictionaryEncoding = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new DictionaryEncoding()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * The known dictionary id in the application where this data is used. In
     * the file or streaming formats, the dictionary ids are found in the
     * DictionaryBatch messages
     *
     * @returns flatbuffers.Long
     */
    DictionaryEncoding.prototype.id = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.readInt64(this.bb_pos + offset) : this.bb.createLong(0, 0);
    };
    /**
     * The dictionary indices are constrained to be non-negative integers. If
     * this field is null, the indices must be signed int32. To maximize
     * cross-language compatibility and performance, implementations are
     * recommended to prefer signed integer types over unsigned integer types
     * and to avoid uint64 indices unless they are required by an application.
     *
     * @param Int= obj
     * @returns Int|null
     */
    DictionaryEncoding.prototype.indexType = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * By default, dictionaries are not ordered, or the order does not have
     * semantic meaning. In some statistical, applications, dictionary-encoding
     * is used to represent ordered categorical data, and we provide a way to
     * preserve that metadata here
     *
     * @returns boolean
     */
    DictionaryEncoding.prototype.isOrdered = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    /**
     * @returns DictionaryKind
     */
    DictionaryEncoding.prototype.dictionaryKind = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : DictionaryKind.DenseArray;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    DictionaryEncoding.startDictionaryEncoding = function (builder) {
        builder.startObject(4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long id
     */
    DictionaryEncoding.addId = function (builder, id) {
        builder.addFieldInt64(0, id, builder.createLong(0, 0));
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset indexTypeOffset
     */
    DictionaryEncoding.addIndexType = function (builder, indexTypeOffset) {
        builder.addFieldOffset(1, indexTypeOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param boolean isOrdered
     */
    DictionaryEncoding.addIsOrdered = function (builder, isOrdered) {
        builder.addFieldInt8(2, +isOrdered, +false);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param DictionaryKind dictionaryKind
     */
    DictionaryEncoding.addDictionaryKind = function (builder, dictionaryKind) {
        builder.addFieldInt16(3, dictionaryKind, DictionaryKind.DenseArray);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    DictionaryEncoding.endDictionaryEncoding = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    DictionaryEncoding.createDictionaryEncoding = function (builder, id, indexTypeOffset, isOrdered, dictionaryKind) {
        DictionaryEncoding.startDictionaryEncoding(builder);
        DictionaryEncoding.addId(builder, id);
        DictionaryEncoding.addIndexType(builder, indexTypeOffset);
        DictionaryEncoding.addIsOrdered(builder, isOrdered);
        DictionaryEncoding.addDictionaryKind(builder, dictionaryKind);
        return DictionaryEncoding.endDictionaryEncoding(builder);
    };
    return DictionaryEncoding;
}());
exports.DictionaryEncoding = DictionaryEncoding;
/**
 * ----------------------------------------------------------------------
 * A field represents a named column in a record / row batch or child of a
 * nested type.
 *
 * @constructor
 */
var Field = /** @class */ (function () {
    function Field() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Field
     */
    Field.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Field= obj
     * @returns Field
     */
    Field.getRootAsField = function (bb, obj) {
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Field= obj
     * @returns Field
     */
    Field.getSizePrefixedRootAsField = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Field()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    Field.prototype.name = function (optionalEncoding) {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
    };
    /**
     * Whether or not this field can contain nulls. Should be true in general.
     *
     * @returns boolean
     */
    Field.prototype.nullable = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;
    };
    /**
     * @returns Type
     */
    Field.prototype.typeType = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? /**  */ (this.bb.readUint8(this.bb_pos + offset)) : Type.NONE;
    };
    /**
     * This is the type of the decoded value if the field is dictionary encoded.
     *
     * @param flatbuffers.Table obj
     * @returns ?flatbuffers.Table
     */
    Field.prototype.type = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__union(obj, this.bb_pos + offset) : null;
    };
    /**
     * Present only if the field is dictionary encoded.
     *
     * @param DictionaryEncoding= obj
     * @returns DictionaryEncoding|null
     */
    Field.prototype.dictionary = function (obj) {
        var offset = this.bb.__offset(this.bb_pos, 12);
        return offset ? (obj || new DictionaryEncoding()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;
    };
    /**
     * children apply only to nested data types like Struct, List and Union. For
     * primitive types children will have length 0.
     *
     * @param number index
     * @param Field= obj
     * @returns Field
     */
    Field.prototype.children = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    /**
     * @returns number
     */
    Field.prototype.childrenLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 14);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * User-defined metadata
     *
     * @param number index
     * @param KeyValue= obj
     * @returns KeyValue
     */
    Field.prototype.customMetadata = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    /**
     * @returns number
     */
    Field.prototype.customMetadataLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 16);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Field.startField = function (builder) {
        builder.startObject(7);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset nameOffset
     */
    Field.addName = function (builder, nameOffset) {
        builder.addFieldOffset(0, nameOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param boolean nullable
     */
    Field.addNullable = function (builder, nullable) {
        builder.addFieldInt8(1, +nullable, +false);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Type typeType
     */
    Field.addTypeType = function (builder, typeType) {
        builder.addFieldInt8(2, typeType, Type.NONE);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset typeOffset
     */
    Field.addType = function (builder, typeOffset) {
        builder.addFieldOffset(3, typeOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset dictionaryOffset
     */
    Field.addDictionary = function (builder, dictionaryOffset) {
        builder.addFieldOffset(4, dictionaryOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset childrenOffset
     */
    Field.addChildren = function (builder, childrenOffset) {
        builder.addFieldOffset(5, childrenOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Offset> data
     * @returns flatbuffers.Offset
     */
    Field.createChildrenVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Field.startChildrenVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset customMetadataOffset
     */
    Field.addCustomMetadata = function (builder, customMetadataOffset) {
        builder.addFieldOffset(6, customMetadataOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Offset> data
     * @returns flatbuffers.Offset
     */
    Field.createCustomMetadataVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Field.startCustomMetadataVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Field.endField = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    Field.createField = function (builder, nameOffset, nullable, typeType, typeOffset, dictionaryOffset, childrenOffset, customMetadataOffset) {
        Field.startField(builder);
        Field.addName(builder, nameOffset);
        Field.addNullable(builder, nullable);
        Field.addTypeType(builder, typeType);
        Field.addType(builder, typeOffset);
        Field.addDictionary(builder, dictionaryOffset);
        Field.addChildren(builder, childrenOffset);
        Field.addCustomMetadata(builder, customMetadataOffset);
        return Field.endField(builder);
    };
    return Field;
}());
exports.Field = Field;
/**
 * ----------------------------------------------------------------------
 * A Buffer represents a single contiguous memory segment
 *
 * @constructor
 */
var Buffer = /** @class */ (function () {
    function Buffer() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Buffer
     */
    Buffer.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * The relative offset into the shared memory page where the bytes for this
     * buffer starts
     *
     * @returns flatbuffers.Long
     */
    Buffer.prototype.offset = function () {
        return this.bb.readInt64(this.bb_pos);
    };
    /**
     * The absolute length (in bytes) of the memory buffer. The memory is found
     * from offset (inclusive) to offset + length (non-inclusive). When building
     * messages using the encapsulated IPC message, padding bytes may be written
     * after a buffer, but such padding bytes do not need to be accounted for in
     * the size here.
     *
     * @returns flatbuffers.Long
     */
    Buffer.prototype.length = function () {
        return this.bb.readInt64(this.bb_pos + 8);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Long offset
     * @param flatbuffers.Long length
     * @returns flatbuffers.Offset
     */
    Buffer.createBuffer = function (builder, offset, length) {
        builder.prep(8, 16);
        builder.writeInt64(length);
        builder.writeInt64(offset);
        return builder.offset();
    };
    return Buffer;
}());
exports.Buffer = Buffer;
/**
 * ----------------------------------------------------------------------
 * A Schema describes the columns in a row batch
 *
 * @constructor
 */
var Schema = /** @class */ (function () {
    function Schema() {
        this.bb = null;
        this.bb_pos = 0;
    }
    /**
     * @param number i
     * @param flatbuffers.ByteBuffer bb
     * @returns Schema
     */
    Schema.prototype.__init = function (i, bb) {
        this.bb_pos = i;
        this.bb = bb;
        return this;
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Schema= obj
     * @returns Schema
     */
    Schema.getRootAsSchema = function (bb, obj) {
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * @param flatbuffers.ByteBuffer bb
     * @param Schema= obj
     * @returns Schema
     */
    Schema.getSizePrefixedRootAsSchema = function (bb, obj) {
        bb.setPosition(bb.position() + flatbuffers_1.flatbuffers.SIZE_PREFIX_LENGTH);
        return (obj || new Schema()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
    };
    /**
     * endianness of the buffer
     * it is Little Endian by default
     * if endianness doesn't match the underlying system then the vectors need to be converted
     *
     * @returns Endianness
     */
    Schema.prototype.endianness = function () {
        var offset = this.bb.__offset(this.bb_pos, 4);
        return offset ? /**  */ (this.bb.readInt16(this.bb_pos + offset)) : Endianness.Little;
    };
    /**
     * @param number index
     * @param Field= obj
     * @returns Field
     */
    Schema.prototype.fields = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? (obj || new Field()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    /**
     * @returns number
     */
    Schema.prototype.fieldsLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 6);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * @param number index
     * @param KeyValue= obj
     * @returns KeyValue
     */
    Schema.prototype.customMetadata = function (index, obj) {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? (obj || new KeyValue()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + offset) + index * 4), this.bb) : null;
    };
    /**
     * @returns number
     */
    Schema.prototype.customMetadataLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 8);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * Features used in the stream/file.
     *
     * @param number index
     * @returns flatbuffers.Long
     */
    Schema.prototype.features = function (index) {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? /**  */ (this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8)) : this.bb.createLong(0, 0);
    };
    /**
     * @returns number
     */
    Schema.prototype.featuresLength = function () {
        var offset = this.bb.__offset(this.bb_pos, 10);
        return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
    };
    /**
     * @param flatbuffers.Builder builder
     */
    Schema.startSchema = function (builder) {
        builder.startObject(4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Endianness endianness
     */
    Schema.addEndianness = function (builder, endianness) {
        builder.addFieldInt16(0, endianness, Endianness.Little);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset fieldsOffset
     */
    Schema.addFields = function (builder, fieldsOffset) {
        builder.addFieldOffset(1, fieldsOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Offset> data
     * @returns flatbuffers.Offset
     */
    Schema.createFieldsVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Schema.startFieldsVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset customMetadataOffset
     */
    Schema.addCustomMetadata = function (builder, customMetadataOffset) {
        builder.addFieldOffset(2, customMetadataOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Offset> data
     * @returns flatbuffers.Offset
     */
    Schema.createCustomMetadataVector = function (builder, data) {
        builder.startVector(4, data.length, 4);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addOffset(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Schema.startCustomMetadataVector = function (builder, numElems) {
        builder.startVector(4, numElems, 4);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset featuresOffset
     */
    Schema.addFeatures = function (builder, featuresOffset) {
        builder.addFieldOffset(3, featuresOffset, 0);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param Array.<flatbuffers.Long> data
     * @returns flatbuffers.Offset
     */
    Schema.createFeaturesVector = function (builder, data) {
        builder.startVector(8, data.length, 8);
        for (var i = data.length - 1; i >= 0; i--) {
            builder.addInt64(data[i]);
        }
        return builder.endVector();
    };
    /**
     * @param flatbuffers.Builder builder
     * @param number numElems
     */
    Schema.startFeaturesVector = function (builder, numElems) {
        builder.startVector(8, numElems, 8);
    };
    /**
     * @param flatbuffers.Builder builder
     * @returns flatbuffers.Offset
     */
    Schema.endSchema = function (builder) {
        var offset = builder.endObject();
        return offset;
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset offset
     */
    Schema.finishSchemaBuffer = function (builder, offset) {
        builder.finish(offset);
    };
    /**
     * @param flatbuffers.Builder builder
     * @param flatbuffers.Offset offset
     */
    Schema.finishSizePrefixedSchemaBuffer = function (builder, offset) {
        builder.finish(offset, undefined, true);
    };
    Schema.createSchema = function (builder, endianness, fieldsOffset, customMetadataOffset, featuresOffset) {
        Schema.startSchema(builder);
        Schema.addEndianness(builder, endianness);
        Schema.addFields(builder, fieldsOffset);
        Schema.addCustomMetadata(builder, customMetadataOffset);
        Schema.addFeatures(builder, featuresOffset);
        return Schema.endSchema(builder);
    };
    return Schema;
}());
exports.Schema = Schema;

//# sourceMappingURL=Schema.js.map
