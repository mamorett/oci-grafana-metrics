{"version":3,"sources":["recordbatch.ts"],"names":[],"mappings":"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","file":"recordbatch.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from './data';\nimport { Table } from './table';\nimport { Vector } from './vector';\nimport { Visitor } from './visitor';\nimport { Schema, Field } from './schema';\nimport { isIterable } from './util/compat';\nimport { Chunked } from './vector/chunked';\nimport { selectFieldArgs } from './util/args';\nimport { DataType, Struct, Dictionary } from './type';\nimport { ensureSameLengthData } from './util/recordbatch';\nimport { Clonable, Sliceable, Applicative } from './vector';\nimport { StructVector, VectorBuilderOptions, VectorBuilderOptionsAsync } from './vector/index';\n\ntype VectorMap = { [key: string]: Vector };\ntype Fields<T extends { [key: string]: DataType }> = (keyof T)[] | Field<T[keyof T]>[];\ntype ChildData<T extends { [key: string]: DataType }> = (Data<T[keyof T]> | Vector<T[keyof T]>)[];\n\nexport interface RecordBatch<T extends { [key: string]: DataType } = any> {\n    concat(...others: Vector<Struct<T>>[]): Table<T>;\n    slice(begin?: number, end?: number): RecordBatch<T>;\n    clone(data: Data<Struct<T>>, children?: Vector[]): RecordBatch<T>;\n}\n\nexport class RecordBatch<T extends { [key: string]: DataType } = any>\n    extends StructVector<T>\n    implements Clonable<RecordBatch<T>>,\n               Sliceable<RecordBatch<T>>,\n               Applicative<Struct<T>, Table<T>> {\n\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull>): Table<T>;\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptionsAsync<Struct<T>, TNull>): Promise<Table<T>>;\n    /** @nocollapse */\n    public static from<T extends { [key: string]: DataType } = any, TNull = any>(options: VectorBuilderOptions<Struct<T>, TNull> | VectorBuilderOptionsAsync<Struct<T>, TNull>) {\n        if (isIterable<(Struct<T>)['TValue'] | TNull>(options['values'])) {\n            return Table.from(options as VectorBuilderOptions<Struct<T>, TNull>);\n        }\n        return Table.from(options as VectorBuilderOptionsAsync<Struct<T>, TNull>);\n    }\n\n    public static new<T extends VectorMap = any>(children: T): RecordBatch<{ [P in keyof T]: T[P]['type'] }>;\n    public static new<T extends { [key: string]: DataType } = any>(children: ChildData<T>, fields?: Fields<T>): RecordBatch<T>;\n    /** @nocollapse */\n    public static new<T extends { [key: string]: DataType } = any>(...args: any[]) {\n        const [fs, xs] = selectFieldArgs<T>(args);\n        const vs = xs.filter((x): x is Vector<T[keyof T]> => x instanceof Vector);\n        return new RecordBatch(...ensureSameLengthData(new Schema<T>(fs), vs.map((x) => x.data)));\n    }\n\n    protected _schema: Schema;\n    protected _dictionaries?: Map<number, Vector>;\n\n    constructor(schema: Schema<T>, length: number, children: (Data | Vector)[]);\n    constructor(schema: Schema<T>, data: Data<Struct<T>>, children?: Vector[]);\n    constructor(...args: any[]) {\n        let data: Data<Struct<T>>;\n        const schema = args[0] as Schema<T>;\n        let children: Vector[] | undefined;\n        if (args[1] instanceof Data) {\n            [, data, children] = (args as [any, Data<Struct<T>>, Vector<T[keyof T]>[]?]);\n        } else {\n            const fields = schema.fields as Field<T[keyof T]>[];\n            const [, length, childData] = args as [any, number, Data<T[keyof T]>[]];\n            data = Data.Struct(new Struct<T>(fields), 0, length, 0, null, childData);\n        }\n        super(data, children);\n        this._schema = schema;\n    }\n\n    public clone(data: Data<Struct<T>>, children = this._children) {\n        return new RecordBatch<T>(this._schema, data, children);\n    }\n\n    public concat(...others: Vector<Struct<T>>[]): Table<T> {\n        const schema = this._schema, chunks = Chunked.flatten(this, ...others);\n        return new Table(schema, chunks.map(({ data }) => new RecordBatch(schema, data)));\n    }\n\n    public get schema() { return this._schema; }\n    public get numCols() { return this._schema.fields.length; }\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = DictionaryCollector.collect(this));\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const nameToIndex = this._schema.fields.reduce((m, f, i) => m.set(f.name as K, i), new Map<K, number>());\n        return this.selectAt(...columnNames.map((columnName) => nameToIndex.get(columnName)!).filter((x) => x > -1));\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        const schema = this._schema.selectAt(...columnIndices);\n        const childData = columnIndices.map((i) => this.data.childData[i]).filter(Boolean);\n        return new RecordBatch<{ [key: string]: K }>(schema, this.length, childData);\n    }\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\n/* eslint-disable @typescript-eslint/naming-convention */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends { [key: string]: DataType } = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        super(schema, 0, schema.fields.map((f) => Data.new(f.type, 0, 0, 0)));\n    }\n}\n\n/** @ignore */\nclass DictionaryCollector extends Visitor {\n    public dictionaries = new Map<number, Vector>();\n    public static collect<T extends RecordBatch>(batch: T) {\n        return new DictionaryCollector().visit(\n            batch.data, new Struct(batch.schema.fields)\n        ).dictionaries;\n    }\n    public visit(data: Data, type: DataType) {\n        if (DataType.isDictionary(type)) {\n            return this.visitDictionary(data, type);\n        } else {\n            data.childData.forEach((child, i) =>\n                this.visit(child, type.children[i].type));\n        }\n        return this;\n    }\n    public visitDictionary(data: Data, type: Dictionary) {\n        const dictionary = data.dictionary;\n        if (dictionary && dictionary.length > 0) {\n            this.dictionaries.set(type.id, dictionary);\n        }\n        return this;\n    }\n}\n"]}