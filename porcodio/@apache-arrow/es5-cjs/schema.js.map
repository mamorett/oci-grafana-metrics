{"version":3,"sources":["schema.ts"],"names":[],"mappings":"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","file":"schema.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from './type';\n\nexport class Schema<T extends { [key: string]: DataType } = any> {\n\n    public readonly fields: Field<T[keyof T]>[];\n    public readonly metadata: Map<string, string>;\n    public readonly dictionaries: Map<number, DataType>;\n\n    constructor(fields: Field[] = [],\n                metadata?: Map<string, string> | null,\n                dictionaries?: Map<number, DataType> | null) {\n        this.fields = (fields || []) as Field<T[keyof T]>[];\n        this.metadata = metadata || new Map();\n        if (!dictionaries) {\n            dictionaries = generateDictionaryMap(fields);\n        }\n        this.dictionaries = dictionaries;\n    }\n    public get [Symbol.toStringTag]() { return 'Schema'; }\n    public toString() {\n        return `Schema<{ ${this.fields.map((f, i) => `${i}: ${f}`).join(', ')} }>`;\n    }\n\n    public select<K extends keyof T = any>(...columnNames: K[]) {\n        const names = columnNames.reduce((xs, x) => (xs[x] = true) && xs, Object.create(null));\n        return new Schema<{ [P in K]: T[P] }>(this.fields.filter((f) => names[f.name]), this.metadata);\n    }\n    public selectAt<K extends T[keyof T] = any>(...columnIndices: number[]) {\n        return new Schema<{ [key: string]: K }>(columnIndices.map((i) => this.fields[i]).filter(Boolean), this.metadata);\n    }\n\n    public assign<R extends { [key: string]: DataType } = any>(schema: Schema<R>): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...fields: (Field<R[keyof R]> | Field<R[keyof R]>[])[]): Schema<T & R>;\n    public assign<R extends { [key: string]: DataType } = any>(...args: (Schema<R> | Field<R[keyof R]> | Field<R[keyof R]>[])[]) {\n\n        const other = (args[0] instanceof Schema\n            ? args[0] as Schema<R>\n            : Array.isArray(args[0])\n                ? new Schema<R>(<Field<R[keyof R]>[]> args[0])\n                : new Schema<R>(<Field<R[keyof R]>[]> args));\n\n        const curFields = [...this.fields] as Field[];\n        const metadata = mergeMaps(mergeMaps(new Map(), this.metadata), other.metadata);\n        const newFields = other.fields.filter((f2) => {\n            const i = curFields.findIndex((f) => f.name === f2.name);\n            return ~i ? (curFields[i] = f2.clone({\n                metadata: mergeMaps(mergeMaps(new Map(), curFields[i].metadata), f2.metadata)\n            })) && false : true;\n        }) as Field[];\n\n        const newDictionaries = generateDictionaryMap(newFields, new Map());\n\n        return new Schema<T & R>(\n            [...curFields, ...newFields], metadata,\n            new Map([...this.dictionaries, ...newDictionaries])\n        );\n    }\n}\n\nexport class Field<T extends DataType = any> {\n\n    public static new<T extends DataType = any>(props: { name: string | number; type: T; nullable?: boolean; metadata?: Map<string, string> | null }): Field<T>;\n    public static new<T extends DataType = any>(name: string | number | Field<T>, type: T, nullable?: boolean, metadata?: Map<string, string> | null): Field<T>;\n    /** @nocollapse */\n    public static new<T extends DataType = any>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        if (args[0] && typeof args[0] === 'object') {\n            ({ name } = args[0]);\n            (type === undefined) && (type = args[0].type);\n            (nullable === undefined) && (nullable = args[0].nullable);\n            (metadata === undefined) && (metadata = args[0].metadata);\n        }\n        return new Field<T>(`${name}`, type, nullable, metadata);\n    }\n\n    public readonly type: T;\n    public readonly name: string;\n    public readonly nullable: boolean;\n    public readonly metadata: Map<string, string>;\n\n    constructor(name: string, type: T, nullable = false, metadata?: Map<string, string> | null) {\n        this.name = name;\n        this.type = type;\n        this.nullable = nullable;\n        this.metadata = metadata || new Map();\n    }\n\n    public get typeId() { return this.type.typeId; }\n    public get [Symbol.toStringTag]() { return 'Field'; }\n    public toString() { return `${this.name}: ${this.type}`; }\n    public clone<R extends DataType = T>(props: { name?: string | number; type?: R; nullable?: boolean; metadata?: Map<string, string> | null }): Field<R>;\n    public clone<R extends DataType = T>(name?: string | number | Field<T>, type?: R, nullable?: boolean, metadata?: Map<string, string> | null): Field<R>;\n    public clone<R extends DataType = T>(...args: any[]) {\n        let [name, type, nullable, metadata] = args;\n        (!args[0] || typeof args[0] !== 'object')\n            ? ([name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata] = args)\n            : ({name = this.name, type = this.type, nullable = this.nullable, metadata = this.metadata} = args[0]);\n        return Field.new<R>(name, type, nullable, metadata);\n    }\n}\n\n/** @ignore */\nfunction mergeMaps<TKey, TVal>(m1?: Map<TKey, TVal> | null, m2?: Map<TKey, TVal> | null): Map<TKey, TVal> {\n    return new Map([...(m1 || new Map()), ...(m2 || new Map())]);\n}\n\n/** @ignore */\nfunction generateDictionaryMap(fields: Field[], dictionaries = new Map<number, DataType>()): Map<number, DataType> {\n\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                dictionaries.set(type.id, type.dictionary);\n            } else if (dictionaries.get(type.id) !== type.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            generateDictionaryMap(type.children, dictionaries);\n        }\n    }\n\n    return dictionaries;\n}\n\n// Add these here so they're picked up by the externs creator\n// in the build, and closure-compiler doesn't minify them away\n(Schema.prototype as any).fields = null;\n(Schema.prototype as any).metadata = null;\n(Schema.prototype as any).dictionaries = null;\n\n(Field.prototype as any).type = null;\n(Field.prototype as any).name = null;\n(Field.prototype as any).nullable = null;\n(Field.prototype as any).metadata = null;\n"]}