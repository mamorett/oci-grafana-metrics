{"version":3,"sources":["io/adapters.ts"],"names":[],"mappings":"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","file":"adapters.js","sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport {\n    toUint8Array,\n    joinUint8Arrays,\n    ArrayBufferViewInput,\n    toUint8ArrayIterator,\n    toUint8ArrayAsyncIterator\n} from '../util/buffer';\n\nimport { ReadableDOMStreamOptions } from './interfaces';\n\ninterface ReadableStreamReadResult<T> { done: boolean; value: T }\ntype Uint8ArrayGenerator = Generator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\ntype AsyncUint8ArrayGenerator = AsyncGenerator<Uint8Array, null, { cmd: 'peek' | 'read'; size: number }>;\n\n/** @ignore */\nexport default {\n    fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n        return pump(fromIterable<T>(source));\n    },\n    fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n        return pump(fromAsyncIterable<T>(source));\n    },\n    fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n        return pump(fromDOMStream<T>(source));\n    },\n    fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n        return pump(fromNodeStream(stream));\n    },\n    // @ts-ignore\n    toDOMStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: ReadableDOMStreamOptions): ReadableStream<T> {\n        throw new Error(`\"toDOMStream\" not available in this environment`);\n    },\n    // @ts-ignore\n    toNodeStream<T>(source: Iterable<T> | AsyncIterable<T>, options?: import('stream').ReadableOptions): import('stream').Readable {\n        throw new Error(`\"toNodeStream\" not available in this environment`);\n    },\n};\n\n/** @ignore */\nconst pump = <T extends Uint8ArrayGenerator | AsyncUint8ArrayGenerator>(iterator: T) => { iterator.next(); return iterator; };\n\n/** @ignore */\nfunction* fromIterable<T extends ArrayBufferViewInput>(source: Iterable<T> | T): Uint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source Iterator\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the iterator\n    const it = toUint8ArrayIterator(source)[Symbol.iterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength) ?\n                it.next(undefined) : it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (it.return(null!));\n    }\n    return null;\n}\n\n/** @ignore */\nasync function* fromAsyncIterable<T extends ArrayBufferViewInput>(source: AsyncIterable<T> | PromiseLike<T>): AsyncUint8ArrayGenerator {\n\n    let done: boolean | undefined, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before creating the source AsyncIterator\n    ({ cmd, size } = (yield <any> null)!);\n\n    // initialize the iterator\n    const it = toUint8ArrayAsyncIterator(source)[Symbol.asyncIterator]();\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it.next(undefined)\n                : await it.next(size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(buffer);\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (typeof it.throw === 'function') && (await it.throw(e));\n    } finally {\n        (threw === false) && (typeof it.return === 'function') && (await it.return(new Uint8Array(0)));\n    }\n    return null;\n}\n\n// All this manual Uint8Array chunk management can be avoided if/when engines\n// add support for ArrayBuffer.transfer() or ArrayBuffer.prototype.realloc():\n// https://github.com/domenic/proposal-arraybuffer-transfer\n/** @ignore */\nasync function* fromDOMStream<T extends ArrayBufferViewInput>(source: ReadableStream<T>): AsyncUint8ArrayGenerator {\n\n    let done = false, threw = false;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we establish the ReadableStream lock\n    ({ cmd, size } = yield <any> null);\n\n    // initialize the reader and lock the stream\n    const it = new AdaptiveByteReader(source);\n\n    try {\n        do {\n            // read the next value\n            ({ done, value: buffer } = isNaN(size - bufferLength)\n                ? await it['read'](undefined)\n                : await it['read'](size - bufferLength));\n            // if chunk is not null or empty, push it onto the queue\n            if (!done && buffer.byteLength > 0) {\n                buffers.push(toUint8Array(buffer));\n                bufferLength += buffer.byteLength;\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } catch (e) {\n        (threw = true) && (await it['cancel'](e));\n    } finally {\n        (threw === false) ? (await it['cancel']())\n            : source['locked'] && it.releaseLock();\n    }\n    return null;\n}\n\n/** @ignore */\nclass AdaptiveByteReader<T extends ArrayBufferViewInput> {\n\n    private supportsBYOB: boolean;\n    private byobReader: ReadableStreamBYOBReader | null = null;\n    private defaultReader: ReadableStreamDefaultReader<T> | null = null;\n    private reader: ReadableStreamBYOBReader | ReadableStreamDefaultReader<T> | null;\n\n    constructor(private source: ReadableStream<T>) {\n        try {\n            this.supportsBYOB = !!(this.reader = this.getBYOBReader());\n        } catch (e) {\n            this.supportsBYOB = !(this.reader = this.getDefaultReader());\n        }\n    }\n\n    get closed(): Promise<void> {\n        return this.reader ? this.reader['closed'].catch(() => {}) : Promise.resolve();\n    }\n\n    releaseLock(): void {\n        if (this.reader) {\n            this.reader.releaseLock();\n        }\n        this.reader = this.byobReader = this.defaultReader = null;\n    }\n\n    async cancel(reason?: any): Promise<void> {\n        const { reader, source } = this;\n        reader && (await reader['cancel'](reason).catch(() => {}));\n        source && (source['locked'] && this.releaseLock());\n    }\n\n    async read(size?: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n        if (size === 0) {\n            return { done: this.reader == null, value: new Uint8Array(0) };\n        }\n        const result = !this.supportsBYOB || typeof size !== 'number'\n            ? await this.getDefaultReader().read()\n            : await this.readFromBYOBReader(size);\n        !result.done && (result.value = toUint8Array(result as ReadableStreamReadResult<Uint8Array>));\n        return result as ReadableStreamReadResult<Uint8Array>;\n    }\n\n    private getDefaultReader() {\n        if (this.byobReader) { this.releaseLock(); }\n        if (!this.defaultReader) {\n            this.defaultReader = this.source['getReader']();\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.defaultReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.defaultReader);\n    }\n\n    private getBYOBReader() {\n        if (this.defaultReader) { this.releaseLock(); }\n        if (!this.byobReader) {\n            this.byobReader = this.source['getReader']({ mode: 'byob' });\n            // We have to catch and swallow errors here to avoid uncaught promise rejection exceptions\n            // that seem to be raised when we call `releaseLock()` on this reader. I'm still mystified\n            // about why these errors are raised, but I'm sure there's some important spec reason that\n            // I haven't considered. I hate to employ such an anti-pattern here, but it seems like the\n            // only solution in this case :/\n            this.byobReader['closed'].catch(() => {});\n        }\n        return (this.reader = this.byobReader);\n    }\n\n    // This strategy plucked from the example in the streams spec:\n    // https://streams.spec.whatwg.org/#example-manual-read-bytes\n    private async readFromBYOBReader(size: number) {\n        return await readInto(this.getBYOBReader(), new ArrayBuffer(size), 0, size);\n    }\n}\n\n/** @ignore */\nasync function readInto(reader: ReadableStreamBYOBReader, buffer: ArrayBufferLike, offset: number, size: number): Promise<ReadableStreamReadResult<Uint8Array>> {\n    if (offset >= size) {\n        return { done: false, value: new Uint8Array(buffer, 0, size) };\n    }\n    const { done, value } = await reader.read(new Uint8Array(buffer, offset, size - offset));\n    if (((offset += value!.byteLength) < size) && !done) {\n        return await readInto(reader, value!.buffer, offset, size);\n    }\n    return { done, value: new Uint8Array(value!.buffer, 0, offset) };\n}\n\n/** @ignore */\ntype EventName = 'end' | 'error' | 'readable';\n/** @ignore */\ntype Event = [EventName, (_: any) => void, Promise<[EventName, Error | null]>];\n/** @ignore */\nconst onEvent = <T extends string>(stream: NodeJS.ReadableStream, event: T) => {\n    const handler = (_: any) => resolve([event, _]);\n    let resolve: (value?: [T, any] | PromiseLike<[T, any]>) => void;\n    return [event, handler, new Promise<[T, any]>(\n        (r) => (resolve = r) && stream['once'](event, handler)\n    )] as Event;\n};\n\n/** @ignore */\nasync function* fromNodeStream(stream: NodeJS.ReadableStream): AsyncUint8ArrayGenerator {\n\n    const events: Event[] = [];\n    let event: EventName = 'error';\n    let done = false, err: Error | null = null;\n    let cmd: 'peek' | 'read', size: number, bufferLength = 0;\n    let buffers: Uint8Array[] = [], buffer: Uint8Array | Buffer | string;\n\n    function byteRange() {\n        if (cmd === 'peek') {\n            return joinUint8Arrays(buffers, size)[0];\n        }\n        [buffer, buffers, bufferLength] = joinUint8Arrays(buffers, size);\n        return buffer;\n    }\n\n    // Yield so the caller can inject the read command before we\n    // add the listener for the source stream's 'readable' event.\n    ({ cmd, size } = yield <any> null);\n\n    // ignore stdin if it's a TTY\n    if ((stream as any)['isTTY']) {\n        yield new Uint8Array(0);\n        return null;\n    }\n\n    try {\n        // initialize the stream event handlers\n        events[0] = onEvent(stream, 'end');\n        events[1] = onEvent(stream, 'error');\n\n        do {\n            events[2] = onEvent(stream, 'readable');\n\n            // wait on the first message event from the stream\n            [event, err] = await Promise.race(events.map((x) => x[2]));\n\n            // if the stream emitted an Error, rethrow it\n            if (event === 'error') { break; }\n            if (!(done = event === 'end')) {\n                // If the size is NaN, request to read everything in the stream's internal buffer\n                if (!isFinite(size - bufferLength)) {\n                    buffer = toUint8Array(stream['read'](undefined));\n                } else {\n                    buffer = toUint8Array(stream['read'](size - bufferLength));\n                    // If the byteLength is 0, then the requested amount is more than the stream has\n                    // in its internal buffer. In this case the stream needs a \"kick\" to tell it to\n                    // continue emitting readable events, so request to read everything the stream\n                    // has in its internal buffer right now.\n                    if (buffer.byteLength < (size - bufferLength)) {\n                        buffer = toUint8Array(stream['read'](undefined));\n                    }\n                }\n                // if chunk is not null or empty, push it onto the queue\n                if (buffer.byteLength > 0) {\n                    buffers.push(buffer);\n                    bufferLength += buffer.byteLength;\n                }\n            }\n            // If we have enough bytes in our buffer, yield chunks until we don't\n            if (done || size <= bufferLength) {\n                do {\n                    ({ cmd, size } = yield byteRange());\n                } while (size < bufferLength);\n            }\n        } while (!done);\n    } finally {\n        await cleanup(events, event === 'error' ? err : null);\n    }\n\n    return null;\n\n    function cleanup<T extends Error | null | void>(events: Event[], err?: T) {\n        buffer = buffers = <any> null;\n        return new Promise<T>((resolve, reject) => {\n            for (const [evt, fn] of events) {\n                stream['off'](evt, fn);\n            }\n            try {\n                // Some stream implementations don't call the destroy callback,\n                // because it's really a node-internal API. Just calling `destroy`\n                // here should be enough to conform to the ReadableStream contract\n                const destroy = (stream as any)['destroy'];\n                destroy && destroy.call(stream, err);\n                err = undefined;\n            } catch (e) { err = e || err; } finally {\n                err != null ? reject(err) : resolve();\n            }\n        });\n    }\n}\n"]}